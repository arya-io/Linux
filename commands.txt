Linux Notes

Basic Commands:
----------------
PATH:
`````
+ Absolute [ /home/natasha/Desktop ] 
+ Relative [ Desktop ]

pwd
- print working directory

cd
- Change Directory

cd path
cd .. [eg: cd ../../]

ls	[ List of dir contents ]
	# pwd
	/
	# ls /root/Desktop

whoami
- To show current logged in user name

mkdir dirname
- Make new directory

touch filename
- To create a blank file (A file without any content)

cat > filename
- To create a new file with text
	e.g: # cat > marvels
		TEXT
		[ctrl+d]-> save & exit

> [Standard output to the program]
< [Standard input to the program]

cat filename
- To show the text of file

cat >> file
- Append the text in existing file.
		e.g: # cat >> marvels
		TEXT2
		[ctrl+d]-> exit

date
- Display current date and time

clear
- To clear the screen/terminal OR ctrl+l

COPY:
-----
a) File to File:
----------------
	# cp srcFilename dstFilename
	OR
	# cp -fv srcFilename dstFilename
	[-f : Forcefully ]
	[-v : Verbose]View the process in detail.

b) File/Dir to Dir
------------------
	# cp -rfv srcFile/Dir dstDir 
[ -r : Recursive ]*
-f : forcefully
-v : verbose (to show process)

man cmd	[ Manual of command ]
	e.g: # man mkdir


REMOVE:
-------
a) A file:
----------
	# rm filename
	# rm -fv  filename
b) A dir:
---------
	# rm -rfv dirname

MOVE: [cut n paste ]
-----
# mv src dst
Move a file from source to destination

# mv oldname newname
This command is used to rename 'oldname' file.

# mkdir .dirname [Hidden Content]
# ls -a [ Show all content with hidden data]

whoami
Display current User name 

echo "msg" : Print the msg on terminal

# tty
- To display terminal name
/dev/pts/0

echo "LOL" > /dev/pts/1
- To display message from one terminal to another terminal

echo "Darlings" > kiki
- To store content directly in a file with echo command


alias:
[ command redirection ]
------
check current alias:

# alias

Create :

# alias money='whoami'

Remove:

# unalias money


Variables:

- User defined var
- System Defined var

a=8

echo "$a"
- 2
echo '$a'
- $a
echo "$a=$a"
- 2=2
echo "\$a=$a"
- $a=2

"" will be used to print the variable value
In interpolation, "" all meta characters are treated as metacharacters.

'' will be used to print the exact text.
In non-interpolation '', all meta characters are treated as string. 


env variable:
-------------
# env

# echo $HISTTIMEFORMAT

%d [Day]
%m [Month]
%y [Year]
%T [Time]

# export HISTTIMEFORMAT="%d-%m-%y %T "
- To add date and time in history command

------
# history
- To show commands history

history -d index_number
- Used to delete a specific indexed history

history -c
- Used to delete entire history

file filename
- Display type of file

mkdir directoryname{1..10}
- To create multiple directories

touch filename{1..10}
- To create multiple files

mkdir -p a/b/c/d
- To create directories from parent to child

`````````````````````````````````````````````````

## If you add a space before running any command, that command will not get stored in history.

`````````````````````````````````````````````````

rmdir directory
- To delete an empty directory

env
- To display environment variables

Find Data:
```````````
Syntax:
```````
# find <where_to_find> -<attrib> <what_to_find>
find /1 -name 2
- To find a particular file name in a particular folder

1) NAME
`````````
# find . -name natasha
# find . -iname natasha
- To display files those are case insensitive
# find /home/edbda/ -iname "*.png"
- To display files those are case insensitive with a particular extension

sort filename
- To sort the content present inside the file.

sort -u filename
- To sort the content present inside the file uniquely.

more filename
- To display content of file according to screensize. Then Percentage will appear on the screen. On pressing More, it will display more content.

wc filename
- Display lines, words and bytes of the filename along with the filename at the end

wc -l filename
- Displays line present in the file

wc -w filename
- Displays words present in the file

wc -c filename
- Displays bytes of the file

We can also use
wc -l -w -c filename

head -n number filename
OF head -number filename
- To display the specified number of top lines of a file

tail -n number filename
OF tail -number filename
- To display the specified number of bottom lines of a file

2) SIZE:
````````
k : KB
G : GB
M : MB

# find /home/edbda -size 2k
# find /home/edbda -size +2k
# find /home/edbda -size -2k
# find /home/edbda -size +2M -size -10M
- To display files with size in that range

3) TYPE:
````````
# find /home/edbda -type f
# find /home/edbda -type d
# find /home/edbda -type f -iname "abc"
- To display files according to their type

4) INDEX NUMBER:
`````````````````
# find /home/edbda -inum 45645456456
- To find out the index number of the files, use command: ls -i

| (pipe sign)
`````````````````

# cmd1 | cmd2
--o/p---->i/p
- Pass the output of one command as the input to the second command

# cat filename
# wc -l filename

# cat data | wc –l

````````````````````````````````````````````````````````````````````````````````````

adduser username
- Create user

id username
- Displays uid and gid of user

id -u username
- Displays user id of user

id -g username
- Displays group id of the user

su - username
- We can switch to another user present on Ubuntu

logout OR exit
- Take back to previous user.

passwd username
- to set the password for user

userdel username
- to delete a user without home directory

userdel -r username
-Used to delete a user account and remove associated files.

gpasswd groupname
- to set the password for group

grep groupname /etc/group
- to search for a specific group (groupname) in the /etc/group file on a Linux system. The /etc/group file contains information about groups and their members.

grep groupname /etc/gshadow
- to search for a specific group (groupname) in the /etc/gshadow file. The /etc/gshadow file contains secure group information, including group passwords, administrators, and members.

grepdel groupname
- delete a group

````````````````````````````````````````````````````````````````````````````````

ADVANCED USERS & GROUP MANAGEMENT:

useradd -u 2000 username
- Create a user with fixed (custom) UID.

usermod -u 2001 username
- Change the UID of an existing user

groupadd -g 9000 groupname
- Create a group with fixed (custom) GID.

groupmod -g 9001 groupname
- Modify the GID of an existing group.

useradd -c "COMMENT" username
- Create a user with comment

usermod -c "MODIFIED COMMENT" username
- Modify the comment for existing user

useradd -m -d /home/homeName username
- Create a user with custom Home Directory

mkdir /home/homeName
usermod -d /home/newhomeName username
- Modify the home directory for existing user

useradd -s /bin/nologin username
- Create a user with custom shell
Here, nologin is non-interactive shell

usermod -s /bin/bash username
- Modify a user with custom shell

To check: grep groupnameORusername /etc/passwd

`````````````````````````````````````````````````````````````````````````````````

grep : 
```````
To search text/string/pattern/regex inside a file

Syntax:
```````
# grep "string" filename
# grep "string1\|string2" filename
- The \| is used as an OR operator to search for either string1 or string2

inverse grep:
````````````
# grep -v "string1" filename
- to invert the match, meaning it returns all lines from the file that do not contain the specified pattern (string1)

# grep -i "s" data
- to search for string1 or string2 in a case-insensitive manner

Metachar
````````
^ : Start of line
$ : End of line

# grep -i "^s" data
# grep -i "s$" data

Only Match
```````````
# grep -o "string" filename

Before & After match
``````````````````````
# grep -B 1 "^i" data
- Displays lines that start with "i" in the file data, along with 1 line before each match.

# grep -A 1 "^i" data
- Displays lines that start with "i" in the file data, along with 1 line after each match.

# grep -A 1 -B 1 "^i" data
- Displays lines that start with "i" in the file data, along with 1 line before and 1 line after each match.

Pattern/Regex:
``````````````
[] : char class

[a-z] : Matches any lowercase letter from 'a' to 'z'.
[A-Z] : Matches any uppercase letter from 'A' to 'Z'.
[0-9] : Matches any digit from '0' to '9'.
[a-zA-Z0-9] : Matches any alphanumeric character (both lowercase and uppercase letters and digits).

Extended grep
# grep -E 
OR
# egrep 

[] : char class
{} : range
[a-z]{10}
[a-z]{10,20}
[a-z]{10,}


QUESTIONS

1. How do you print the lines between 5 and 10, both inclusive

Answer: # head -10 filename | tail -6



2. Create a new file “new.txt” that is a concatenation of “file1.txt” and “file2.txt”

# cat file1.txt file2.txt > new.txt



3. What is the output of the following code:

os=Unix
echo 1.$os 2."$os" 3.'$os' 4.$os



4. To feed standard output of one command to standard input of another in a single shell session. example?

|


5.  Output of this command: 
cat < file1 >> file2 | file3

Syntax error




VIM EDITOR:


update:
`````````
# apt update 

Upgrade:
````````
# apt upgrade

Install:
```````````
# apt install package_name

Uninstall:
``````````
# apt autoremove package_name

\

Command line mode commands:
````````````````````````````
i : Take you to insert mode
Esc : Go back to command line mode
G : Take you to end of file.
yy : yanked (copy) the current line and press p for paste below OR P for paste above
nyy : yanked ( copy) n number of lines
p : paste
dd : cut the current line
ndd : cut n number of lines
u : undo
ctrl + r : redu

Last line actions:
```````````````````
:set nu : show line numbers
:set nonu : remove line numbers
:line_number : take you to specific line
/word : search a word,to go to next occurrence press n
To go to previous occurrence press N
:%s/old_word/new_word : search and replace
:%s/old_word/new_word/g : search and replace
:wq save and quit
:w save
:q quit
:w! save forcefully
:q! quit forcefully
:wq! Save and quit forcefully



Basic Permissions: [ File based ]
------------------

1) Symbolic Method
===================
read	: r
write	: w
execute	: x
------------
user owner	: u
group owner	: g
Others		: o
All		: a
------------
Assign		: +
Remove		: -
Overwrite	: =
------------


Permission Area:
----------------
--- : user owner
--- : group owner
--- : Others

# ls -l
-rw-r--r-- 1 root root   43 Sep 23 01:56 file1





Default permissions for file: 
-----------------------------
read & write	: u
read		: g
read		: o

Default permissions for dir: 
----------------------------
read, write & execute	: u
read & execute		: g
read & execute		: o

Change permissions in Symbolic method:
---------------------------------------
# chmod u+rx file/dir
# chmod u-r,g+rw,o-rwx file/dir
# chmod u=rw file/dir
# chmod ugo=r file/dir
# chmod a=r file/dir
# chmod +x file/dir

2) Numeric Method
-----------------

read	: 4
write	: 2
execute	: 1
Full	: 7
No	: 0

---	000	0
r--	100	4	
-w-	010	2
--x	001	1
rwx	111	7

# chmod 711 file/dir
# chmod 111 dir -R
[-R : recursively]


Questions

Q. Create a collaborative directory /common/adm with the following characteristics:

-Group ownership of /common/adm is admin

-The directory should be readable, writable, and accessible to members of admin, but not to any other user. (It is understood that root has access to all ﬁles and directories on the system.)



Q. Copy the ﬁle /etc/fstab to /var/tmp. Conﬁgure the permissions of /var/tmp/fstab so that: 

-The ﬁle /var/tmp/fstab is owned by the root user.

-The ﬁle /var/tmp/fstab belongs to the group root.

-The ﬁle /var/tmp/fstab should not be executable by anyone.

-The user harry is able to read and write /var/tmp/fstab.

-The user natasha can neither write nor read /var/tmp/fstab.

-all other users (current or future) have the ability to read /var/tmp/fstab 

Q. Create a Command Shell Environment : 
-Create a command qstat.

-It should able to execute the following command 
( ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm )



Process Management:

```````````````````
Process:
````````
- Any running program is a process
- Multiple instances of the same program are processes.
- Shell is also a process


Process ID (PID)
````````````````
- Each linux process is identified by unique id PID 
- Every process has a Parent Process ID (PPID)
	+ Except "init"

Create a Process:
`````````````````
Terminal#1
```````````
# sleep 100

Terminal#2
```````````
# ps -la		[ Show the processes with PID & PPID ]

Managing Processes:
````````````````````
- Linux kernel tracks what each process is doing
- Process is assigned a priority
- Address space assigned to the process
- Files is the process allowed to access
- Is the process a ?:-
	+ Parent
	+ Child
	+ Zombie

=> Sometimes the parent dies first
``````````````````````````````````
- If the parent just exits or dies, the child process is left running
- The child's PPID is no longer valid due to parent is gone.
- Linux calls these children processes "Zombies"
- In Linux a zombie is just a process in which the children are adopted by the "init" process
- The init process will eventually cleanup the zombie childrens

PPID[kill]
	\___________PID[kill]

PPID[die]
	\___________PID[zombie]

process manager: 
````````````````
ps, top, htop
``````````````
# top

press 'q' to exit


# sleep 10 &

# ps 		[ PID - Process ID]
# ps -l 	[ Show the PPID - Parent PID ]
# ps -e		[ All the processes ]

# ps -la

Kill:
-----
# kill PID
OR
# kill -9 PID

-9 : Forcefully

# pkill sleep

# killall sleep
--------------------


# sleep 10000 &
# sleep 20000 &




Check backgroup process:

# jobs
[1]-  Running                 sleep 10000 &
[2]+  Running                 sleep 20000 &

-  : Second last added in jobs
+  : last added in jobs

# jobs -l	[ with PID ]
[1]-   971 Running                 sleep 10000 &
[2]+   972 Running                 sleep 20000 &


# fg %2

ctrl+z [stop]

# bg %2 [ To start in BG ]
+++++++++++++++++++++++++++++++++++

1. Create the following users, groups, and group memberships:

-A group named admin
# groupadd admin

-A user harry who belongs to admin as a secondary group
# useradd -G admin harry

-A user natasha who also belongs to admin as a secondary group
# useradd -G admin natasha

-A user sarah who does not have access to an interactive shell on the system, and who is not a member of admin
# useradd -s /bin/nologin sarah

-harry, natasha, and sarah should all have the password of "redhat@123?"
# passwd user



Q. You need to change the permissions of a file named schedule.txt such that the file owner can edit the file, users who are members of the group that owns the file can edit it, and users who are not owners and don't belong to the owning group can view it but not modify it. Which command will do this?

224



Q. Your Linux system's umask variable is currently set to a value of 077. A user named 'jason' (who is a member of the users group) creates a dir named /tasks. What can users who are members of the users group do with this file?



777 - 077 = 700



Q. Create a collaborative directory /common/adm with the following characteristics:

-Group ownership of /common/adm is admin

-The directory should be readable, writable, and accessible to members of admin, but not to any other user. (It is understood that root has access to all ﬁles and directories on the system.)



Q. Create a collaborative directory /common/adm with the following characteristics:

-Group ownership of /common/adm is admin

-The directory should be readable, writable, and accessible to members of admin, but not to any other user. (It is understood that root has access to all ﬁles and directories on the system.)

# mkdir -p /common/adm
# chgrp admin /common/adm
# chmod 770 /common/adm


Q. Copy the ﬁle /etc/fstab to /var/tmp. Conﬁgure the permissions of /var/tmp/fstab so that: 

-The ﬁle /var/tmp/fstab is owned by the root user.
-The ﬁle /var/tmp/fstab belongs to the group root.
-The ﬁle /var/tmp/fstab should not be executable by anyone.
-The user harry is able to read and write /var/tmp/fstab.
-The user natasha can neither write nor read /var/tmp/fstab.
-all other users (current or future) have the ability to read /var/tmp/fstab 

# cp -rfv /etc/fstab /var/tmp/
# chown root /var/tmp/fstab
# chgrp root /var/tmp/fstab
# setfacl -m u:harry:6 /var/tmp/fstab
# setfacl -m u:natasha:0 /var/tmp/fstab
# chmod o=r /var/tmp/fstab


Q. Create a Command Shell Environment : 
-Create a command qstat.

-It should able to execute the following command 
( ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm )

# alias qstat='ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm'
# qstat


Shell Scripting:
----------------To run multiple objects[binary/commands] using a single object[file].

.sh || .bash 

# vim runme.sh

#!/bin/bash	 [env declaration]SHEBANG
cmd1
cmd2
cmd3

:wq [Save & Quit]

# chmod u+x runme.sh
# ./runme.sh
OR
# bash runme.sh



==> Debug:
----------

# bash -x runme.sh







~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Variable:
---------
#!/bin/bash
target="example.com"
echo "My target for today is: $target"
echo "My target for today is: ${target}"

----------
#!/bin/bash
read -p "Enter the target: " target
echo "My target for today is: ${target}"
echo "My target for today is: ${target:-DEFAULT}"
-----------







#!/bin/bash
target=$(whoami)
echo "My user for today is: $target"
-----------
#!/bin/bash
target=`whoami`
echo "My user for today is: $target"
-----------






Arithmetic
~~~~~~~~~~~
x=10
y=2
echo $(($x + $y))
--------
read -p "Enter first: " x
read -p "Enter second: " y
echo $(($x + $y))
	--------
#!/bin/bash
expr 2 + 2
expr 2 - 2
expr 2 / 2
expr 2 \* 2
===============================
Conditions:
```````````
1) if...then...fi
2) if...then...else...fi
3) if...then...elif...then...fi
4) if...then...elif...then...else...fi


1) if...then...fi
````````````````````
#!/bin/bash
read -p "Enter: " a

if [[ $a == "0" ]];then
	echo "Ch mayla"
fi




2) if...then...else...fi
`````````````````````````
#!/bin/bash
read -p "Enter: " a

if [[ $a == "0" ]];then
	echo "Ch mayla"
else
	echo "Tumse na ho payega"
fi



3) if...then...elif...then...fi
`````````````````````````````````
#!/bin/bash
read -p "Enter: " a

if [[ $a == "0" ]];then
	echo "WoW"
elif [[ $a == "1" ]];then
	echo "Kidding"
fi




4) if...then...elif...then...else...fi
```````````````````````````````````````
#!/bin/bash
read -p "Enter: " a

if [[ $a == "0" ]];then
	echo "WoW"
elif [[ $a == "1" ]];then
	echo "Kidding"
else 
	echo "Don't take it lightly"
fi

1) Relational Operator:
```````````````````````
String comparisons: ==, !=, <, <=, >, >=, =~, !~
Numeric Comparisons: -eq, -ne, -lt, -le, -gt, -ge










[[ NUM == NUM ]]	Equal
[[ NUM != NUM ]]	Not Equal
[[ STRING -eq STRING ]]		Equal
[[ STRING -ne STRING ]]		Not equal
[[ STRING -lt STRING ]]		Less than
[[ STRING -le STRING ]]		Less than or equal
[[ STRING -gt STRING ]]		Greater than
[[ STRING -ge STRING ]]		Greater than or equal
[[ STRING =~ STRING ]]	Match RegEx
[[ STRING !~ STRING ]]	Not-Match RegEx

File Ops:
``````````
[[ -e FILE ]]	Exists
[[ -r FILE ]]	Readable
[[ -w FILE ]]	Writable
[[ -x FILE ]]	Executable
[[ -f FILE ]]	File
[[ -d FILE ]]	Directory
[[ -z STRING ]]	Empty string/var
[[ -n STRING ]]	Not empty string/var
[[ -s FILE ]] : File size not empty
[[ ! -s FILE ]] : File size empty




2) Logical Operators:
``````````````````````
||, &&, !

[[ $a == "0" ]] && [[ $b == "1" ]]

[[ $a == "0" ]] || [[ $b == "1" ]]

[[ ! -z $VAR ]] : Not Empty























-----------

1) if...then...fi
2) if...then...else...fi
3) if...then...elif...then...fi

#!/bin/bash
read -p "Enter value: " a
if [ $a == "1" ]
then
echo "It done"
fi

2) if...then...else...fi

#!/bin/bash
read -p "Enter value: " a
if [ $a == "1" ]
then
echo "It done"
else
echo "WTF"
fi


3) if...then...elif...then...fi

#!/bin/bash
read -p "Enter value: " a
if [ $a == "1" ]
then
echo "It done"
elif [ $a == "2" ]
then 
echo "Its FUN"
fi

4) if...then...elif...then...else...fi

#!/bin/bash
read -p "Enter value: " a
if [ $a == "1" ]
then
echo "It done"
elif [ $a == "2" ]
then
echo "Its FUN"
else
echo "WTF"
fi










while loop:
-----------


while true
do
echo "LOL"
done

# while true;do echo "LOL";done

redirect/stdin 
--------
# cat > file
Dheeraj
Tabish
Amruta
Mayur

# while read -r name; do echo "Name: $name";done < file

# cat file | while read -r name; do echo "Name: $name";done
----------------------------

TOOL:
-----

example.com		DOMAIN
admin.example.com	SUB DOMAIN

DNS

name - IP
IP - name
------


Target : yahoo.com


# vim subtool.sh
#!/bin/bash
target=$1
file=$2
while read -r sub; do
        if host "$sub.$target" &> /dev/null; then
                echo "$sub.$target"
        fi
done < $file









nested if:
----------

#!/bin/bash
file=$1

if [ -f "$file" ]; then
	if [ -w "$file" ]; then
		echo "Enter text:"
		cat >> $file
	else
		echo "Not writable"
	fi
else
	echo "$file not found"
fi












Functions:
----------


#!/bin/bash
target=$1
file=$2

brute(){
	while read -r sub; do
        if host "$sub.$target" &> /dev/null; then
                echo "$sub.$target"
        fi
	done < $file
}

if [ -f "$file" ]; then
	brute
else
	echo "$file not found"
fi
----------------------------------------------------------









CASE in BASH
------------

#!/bin/bash
f1(){
        echo "F1 is cool"
}
f2(){
        echo "F2 is awesome"
}
menu(){
        echo -e "1. Func 1\n2. Fun 2\n3. exit"
        read -p "Input> " a
}
menu
case $a in
        "1")
                f1
                ;;
        "2")
                f2
                ;;
        "3")
                exit
                ;;
        *)
                echo "WTF"
                ;;
esac
